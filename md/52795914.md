转载请注明出处：

http://blog.csdn.net/gane_cheng/article/details/52795914

http://www.ganecheng.tech/blog/52795914.html （浏览效果更好）

**SSH 和 SSM 的定义**
-----------------

本人经历过两种技术架构，分别是常说的 SSH 和 SSM ，SSH 在本科的时候老师就教过。SSM 则是去公司后用的比较多。现在我想将这两大阵营的技术做一下对比。由于本人能力有限，涉及技术较多，我只从具体的应用方面做一些对比。

**SSH** 通常指的是 Struts2 做前端控制器，Spring 管理各层的组件，Hibernate 负责持久化层。

**SSM** 则指的是 SpringMVC 做前端控制器，Spring 管理各层的组件，MyBatis 负责持久化层。

共同之处是都使用了Spring的依赖注入DI来管理各层的组件，使用了面向切面编程AOP来实现日志管理，权限认证，事务等通用功能的切入。

不同之处是 Struts2 和 SpringMVC 做前端控制器的区别，以及 Hibernate 和 MyBatis 做持久化时的区别。但是，Struts2 也可以和 MyBatis 搭配使用，SpringMVC 也可以和 Hibernate 搭配使用。本文为了简化对比，指定 Struts2 要和 Hibernate 搭配，SpringMVC 要和 MyBatis 搭配。



**SSH 和 SSM 的实现原理区别**
---------------------

| 所在分层 | SSH | SSM |
| ------------- |:-------------:| :-----:|
| 页面层(View) | JSP | JSP |
| 控制器层(Controller) | **Struts2** | **SpringMVC** |
| 业务层(Service) | Java | Java |
| 持久层(DAO) | **Hibernate** | **MyBatis** |
| 数据库层(DB) | MySQL/Oracle | MySQL/Oracle |
| 组件管理(Bean) | **Spring** | **Spring** |


----------
**(1) Struts2 的原理**

![这里写图片描述](http://img.blog.csdn.net/20161012124611323)

一个请求在Struts2框架中的处理大概分为以下几个步骤：

1、客户端初始化一个指向Servlet容器（例如Tomcat）的请求

2、这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh Plugin） 

3、接着FilterDispatcher被调用，FilterDispatcher询问ActionMapper来决定这个请求是否需要调用某个Action 

FilterDispatcher是控制器的核心，就是mvc中c控制层的核心。下面粗略的分析下FilterDispatcher工作流程和原理：FilterDispatcher进行初始化并启用核心doFilter。

```
   public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {

        showDeprecatedWarning();

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;
        ServletContext servletContext = getServletContext();

        String timerKey = "FilterDispatcher_doFilter: ";
        try {

            // FIXME: this should be refactored better to not duplicate work with the action invocation
            ValueStack stack = dispatcher.getContainer().getInstance(ValueStackFactory.class).createValueStack();
            ActionContext ctx = new ActionContext(stack.getContext());
            ActionContext.setContext(ctx);

            UtilTimerStack.push(timerKey);
            request = prepareDispatcherAndWrapRequest(request, response);
            ActionMapping mapping;
            try {
	            //在这里找到Action的映射器
                mapping = actionMapper.getMapping(request, dispatcher.getConfigurationManager());
            } catch (Exception ex) {
                log.error("error getting ActionMapping", ex);
                dispatcher.sendError(request, response, servletContext, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, ex);
                return;
            }
			//没有此Action的话,就去查找静态资源
            if (mapping == null) {
                // there is no action in this request, should we look for a static resource?
                String resourcePath = RequestUtils.getServletPath(request);

                if ("".equals(resourcePath) && null != request.getPathInfo()) {
                    resourcePath = request.getPathInfo();
                }

                if (staticResourceLoader.canHandle(resourcePath)) {
                    staticResourceLoader.findStaticResource(resourcePath, request, response);
                } else {
                    // this is a normal request, let it pass through
                    chain.doFilter(request, response);
                }
                // The framework did its job here
                return;
            }
			//有此Action的话则把控制权交给ActionProxy
            dispatcher.serviceAction(request, response, servletContext, mapping);

        } finally {
            dispatcher.cleanUpRequest(request);
            try {
                ActionContextCleanUp.cleanUp(req);
            } finally {
                UtilTimerStack.pop(timerKey);
            }
            devModeOverride.remove();
        }
    }
```
4、如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxy

```
    public void serviceAction(HttpServletRequest request, HttpServletResponse response, ServletContext context,
                              ActionMapping mapping) throws ServletException {

        Map<String, Object> extraContext = createContextMap(request, response, mapping, context);

        // If there was a previous value stack, then create a new copy and pass it in to be used by the new Action
        ValueStack stack = (ValueStack) request.getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);
        boolean nullStack = stack == null;
        if (nullStack) {
            ActionContext ctx = ActionContext.getContext();
            if (ctx != null) {
                stack = ctx.getValueStack();
            }
        }
        if (stack != null) {
            extraContext.put(ActionContext.VALUE_STACK, valueStackFactory.createValueStack(stack));
        }

        String timerKey = "Handling request from Dispatcher";
        try {
            UtilTimerStack.push(timerKey);
            String namespace = mapping.getNamespace();
            String name = mapping.getName();
            String method = mapping.getMethod();

			//获取配置文件
            Configuration config = configurationManager.getConfiguration();
            //根据配置文件找到此Action并生成ActionProxy
            ActionProxy proxy = config.getContainer().getInstance(ActionProxyFactory.class).createActionProxy(
                    namespace, name, method, extraContext, true, false);

            request.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, proxy.getInvocation().getStack());

            // if the ActionMapping says to go straight to a result, do it!
            if (mapping.getResult() != null) {
                Result result = mapping.getResult();
                //ActionProxy创建一个ActionInvocation的实例
                result.execute(proxy.getInvocation());
            } else {
                proxy.execute();
            }

            // If there was a previous value stack then set it back onto the request
            if (!nullStack) {
                request.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, stack);
            }
        } catch (ConfigurationException e) {
            logConfigurationException(request, e);
            sendError(request, response, context, HttpServletResponse.SC_NOT_FOUND, e);
        } catch (Exception e) {
            if (handleException || devMode) {
                sendError(request, response, context, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e);
            } else {
                throw new ServletException(e);
            }
        } finally {
            UtilTimerStack.pop(timerKey);
        }
    }
```

5、ActionProxy通过Configuration Manager询问框架的配置文件，找到需要调用的Action类

6、ActionProxy创建一个ActionInvocation的实例。

7、ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。 

8、一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可 能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。

9、将处理结果返回给客户端

**(2) SpringMVC 的原理**


![这里写图片描述](http://img.blog.csdn.net/20161011155831879)

**执行步骤:**

**第一步：发起请求到前端控制器(DispatcherServlet)**

**第二步：前端控制器请求HandlerMapping查找 Handler**
				可以根据xml配置、注解进行查找
				
**第三步：处理器映射器HandlerMapping向前端控制器返回Handler**

**第四步：前端控制器调用处理器适配器去执行Handler**

**第五步：处理器适配器去执行Handler**

**第六步：Handler执行完成给适配器返回ModelAndView**

**第七步：处理器适配器向前端控制器返回ModelAndView**
				ModelAndView是SpringMVC框架的一个底层对象，包括 Model和view

**第八步：前端控制器请求视图解析器去进行视图解析**
				根据逻辑视图名解析成真正的视图(jsp)

**第九步：视图解析器向前端控制器返回View**

**第十步：前端控制器进行视图渲染**
				视图渲染将模型数据(在ModelAndView对象中)填充到request域

**第十一步：前端控制器向用户响应结果** 

**(3) Hibernate 的原理**

1.通过Configuration().configure();读取并解析hibernate.cfg.xml配置文件

2.由hibernate.cfg.xml中的`<mapping resource="com/xx/User.hbm.xml"/>`读取并解析映射信息

3.通过config.buildSessionFactory();//创建SessionFactory

4.sessionFactory.openSession();//打开Sesssion

5.session.beginTransaction();//创建事务Transation

6.persistent operate持久化操作

7.session.getTransaction().commit();//提交事务

8.关闭Session

9.关闭SesstionFactory

**(4) MyBatis原理**

![这里写图片描述](http://img.blog.csdn.net/20161007161731534)

MyBatis框架执行过程：

1、配置MyBatis的配置文件，SqlMapConfig.xml（名称不固定）

2、通过配置文件，加载MyBatis运行环境，创建SqlSessionFactory会话工厂 
SqlSessionFactory 在实际使用时按单例方式。

3、通过SqlSessionFactory创建SqlSession 
SqlSession 是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。

4、调用 sqlSession 的方法去操作数据。 
如果需要提交事务，需要执行 SqlSession 的 commit() 方法。

5、释放资源，关闭SqlSession

**Struts2 和 SpringMVC 在 web.xml 中配置的不同**
-----------------------------------

(1) Struts2

```
<filter>  
    <filter-name>struts2</filter-name>  
    <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>  
    <init-param>  
        <param-name>filterConfig</param-name>  
        <param-value>classpath:struts2/struts.xml</param-value>  
    </init-param>  
</filter>  
<filter-mapping>  
    <filter-name>struts2</filter-name>  
    <url-pattern>/*</url-pattern>  
</filter-mapping>  
```

Struts2使用Filter嵌入自己的框架。配置文件加载顺序为：default.properties -> struts-default.xml -> struts-plugins.xml -> struts.xml -> struts.locale。

加载顺序可以参考这篇文章的源码分析了解更多。[https://my.oschina.net/gschen/blog/121433](https://my.oschina.net/gschen/blog/121433)

(2) SpringMVC

```
	<!-- springmvc前端控制器，rest配置 -->
	<servlet>
		<servlet-name>springmvc_rest</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） -->
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:spring/springmvc.xml</param-value>
		</init-param>
	</servlet>

	<servlet-mapping>
		<servlet-name>springmvc_rest</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>
```

SpringMVC使用Servlet嵌入自己的框架。

（3）web.xml不同之处

**SpringMVC的入口是Servlet**，而**Struts2是Filter**（这里要指出，Filter和Servlet是不同的。以前认为filter是servlet的一种特殊），这就导致了二者的机制不同，这里就牵涉到Servlet和Filter的区别了。但是这只是接管用户请求的两种不同方式而已，控制权被Struts2和SpringMVC掌握之后，想做什么事都是可以做到的。

**Servlet**

servlet是一种运行服务器端的java应用程序，具有独立于平台和协议的特性，并且可以动态的生成web页面，它工作在客户端请求与服务器响应的中间层。最早支持 Servlet 技术的是 JavaSoft 的 Java Web Server。此后，一些其它的基于 Java 的 Web Server 开始支持标准的 Servlet API。Servlet 的主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。这个过程为：
	
	1) 客户端发送请求至服务器端；
	2) 服务器将请求信息发送至 Servlet；
	3) Servlet 生成响应内容并将其传给服务器。响应内容动态生成，通常取决于客户端的请求；
	4) 服务器将响应返回给客户端。
	在 Web 应用程序中，一个 Servlet 在一个时刻可能被多个用户同时访问。这时 Web 容器将为每个用户创建一个线程来执行 Servlet。如果 Servlet 不涉及共享资源的问题，不必关心多线程问题。但如果 Servlet 需要共享资源，需要保证 Servlet 是线程安全的。
	为了简化开发流程，Servlet 3.0 引入了注解（annotation），这使得 web 部署描述符 web.xml 不再是必须的选择。

**Filter**：Filter是一个可以复用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。Servlet中的过滤器Filter是实现了javax.servlet.Filter接口的服务器端程序，主要的用途是过滤字符编码、做一些业务逻辑判断等。其工作原理是，只要你在web.xml文件配置好要拦截的客户端请求，它都会帮你拦截到请求，此时你就可以对请求或响应(Request、Response)统一设置编码，简化操作；同时还可进行逻辑判断，如用户是否已经登陆、有没有权限访问该页面等等工作。它是随你的web应用启动而启动的，只初始化一次，以后就可以拦截相关请求，只有当你的web应用停止或重新部署的时候才销毁。Filter可认为是Servlet的一种“变种”，它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。它与Servlet的区别在于：它不能直接向用户生成响应。完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。

Servlet与Filter的区别可以从这篇文章了解更多。[http://www.cnblogs.com/doit8791/p/4209442.html](http://www.cnblogs.com/doit8791/p/4209442.html)

**Struts2 和 SpringMVC 处理用户请求的不同**
------------------------------

Struts2和SpringMVC的核心都是接管用户的请求，解决传统Servlet开发过于繁琐，重用性不高的问题。

Struts2和SpringMVC都有注解和配置文件两种匹配用户请求URL的方式。

**Struts2注解方式匹配URL**

参考网址：[http://struts.apache.org/docs/convention-plugin.html](http://struts.apache.org/docs/convention-plugin.html)

首先需要将架包(struts2-convention-plugin-xxx.jar)导入工程中

示例

```
package com.example.actions;  
  
import com.opensymphony.xwork2.ActionSupport;   
import org.apache.struts2.convention.annotation.Action;  
import org.apache.struts2.convention.annotation.Actions;  
import org.apache.struts2.convention.annotation.Result;  
import org.apache.struts2.convention.annotation.Results;  
  
@Results({  
  @Result(name="failure", location="fail.jsp")  
})  
public class HelloWorld extends ActionSupport 
{  
  @Action(value="/different/url",   
    results={@Result(name="success", location="http://struts.apache.org", type="redirect")}  
  )  
  public String execute() 
  {  
    return SUCCESS;  
  }  
  
  @Action("/another/url")  
  public String doSomething()
  {  
    return SUCCESS;  
  }  
}  
```

**Struts2配置方式匹配URL**

```
	<package name="package" namespace="/different" extends="struts-default">
		<global-results>
			<result name="failure">/fail.jsp</result>
		</global-results>

		<action name="url" class="com.example.actions.HelloWorld" method="execute">
			<result name="success" type="redirect">http://struts.apache.org</result>
		</action>
	</package>
	
	<package name="package2" namespace="/another" extends="struts-default">
		<global-results>
			<result name="failure">/fail.jsp</result>
		</global-results>

		<action name="url" class="com.example.actions.HelloWorld" method="doSomething">
			
		</action>
	</package>
```

**SpringMVC注解方式匹配URL**

```
package com.jpkc.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;


@RequestMapping("/admin")
@Controller
public class LoginController
{	
	@RequestMapping("/admin_home")
	public String admin_home() throws Exception
	{
		return "forward:/shop/index.jsp";
	}

	@RequestMapping("/exit")
	public String logout(ModelAndView model, HttpSession session) throws Exception
	{
		session.invalidate();
		return "redirect:/manager/login.jsp";
	}
}

```

**SpringMVC配置方式匹配URL**

```
public class ItemsController1 implements Controller 
{
    @Override
    public ModelAndView handleRequest(HttpServletRequest request,
            HttpServletResponse response) throws Exception 
    {

        //调用Service查找 数据库，查询商品列表，这里使用静态数据模拟
        List<Items> itemsList = new ArrayList<Items>();
        //向list中填充静态数据

        Items items_1 = new Items();
        items_1.setName("联想笔记本");
        items_1.setPrice(6000f);
        items_1.setDetail("ThinkPad T430 联想笔记本电脑！");

        Items items_2 = new Items();
        items_2.setName("苹果手机");
        items_2.setPrice(5000f);
        items_2.setDetail("iphone6苹果手机！");

        itemsList.add(items_1);
        itemsList.add(items_2);

        //返回ModelAndView
        ModelAndView modelAndView =  new ModelAndView();
        //相当 于request的setAttribut，在jsp页面中通过itemsList取数据
        modelAndView.addObject("itemsList", itemsList);

        //指定视图
        modelAndView.setViewName("/WEB-INF/jsp/items/itemsList.jsp");

        return modelAndView;
    }
}
```

```
<!-- 配置Handler -->
<bean id="itemsController1" name="/queryItems.action" class="cn.itcast.ssm.controller.ItemsController1" />
```


----------
1、Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应,所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。

2、由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。

3、由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。

**Struts2 和 SpringMVC 实现 RESTful 的不同**
------------------------------

http://localhost/jpkc/item/1609032329404095427579225

实现上面这个链接，其中localhost是域名，jpkc是项目名。

**Struts2实现方式**

```
	<package name="course_info_package" namespace="/item" extends="struts-default">
		<action name="*" class="com.jpkc.action.CourseAction" method="get_course_info">
			<result name="success">/story/story_02.jsp</result>
		</action>
	</package>
```

```
public class CourseAction extends ActionSupport
{
	public String get_course_info()
	{
		String actionName = ServletActionContext.getActionMapping().getName();
		CourseInfo courseInfoFromDB = courseInfoDAO.findById(actionName);
		if (courseInfoFromDB == null)
		{
			return "404";
		}

		Course courseFromDB = courseDAO.findById(actionName);
		if (courseFromDB == null)
		{
			return "404";
		}

		setCourseInfo(courseInfoFromDB);
		setCourse(courseFromDB);

		return SUCCESS;
	}
}
```


**SpringMVC实现方式**

```
@Controller
public class CourseController
{
	@RequestMapping("/item/{id}")
	public ModelAndView get_course_info(ModelAndView model, @PathVariable("id") String id)
	{
		if (CM.validIsEmptyWithTrim(id))
		{
			model.addObject("message", "没有找到此视频页面");
			model.setViewName("/WEB-INF/jsp/error");
			return model;
		}

		CourseInfo courseInfoFromDB=null;
		try
		{
			courseInfoFromDB = courseInfoService.selectByPrimaryKey(id);
		}
		catch (Exception e1)
		{
			System.out.println("没有找到课程信息");
		}
		if (courseInfoFromDB == null)
		{
			model.addObject("message", "没有找到此视频页面");
			model.setViewName("/WEB-INF/jsp/error");
			return model;
		}

		Course courseFromDB = null;
		try
		{
			courseFromDB = courseService.selectByPrimaryKey(id);
		}
		catch (Exception e)
		{
			System.out.println("没有查找到课程");
		}
		if (courseFromDB == null)
		{
			model.addObject("message", "没有找到此视频页面");
			model.setViewName("/WEB-INF/jsp/error");
			return model;
		}

		model.addObject("courseInfo", courseInfoFromDB);
		model.addObject("course", courseFromDB);
		model.setViewName("/story/story_02");
		return model;
	}

}

```


----------
对于类似于http://localhost/jpkc/item/id1这种链接，Struts2实现RESTful风格需要在代码中调用ServletActionContext.getActionMapping().getName()获取ActionName。SpringMVC直接将链接映射到方法参数里去了。

如果类似于http://localhost/jpkc/id2/id1这种链接，Struts2要进一步分析链接得到id1和id2。SpringMVC依然可以将id2映射到方法参数上。从调用的角度来看SpringMVC要方便一些。但是如果将Struts2获取方式封装一下，也可以得到同样的效果。


**Struts2 和 SpringMVC 获取 request 参数的不同**
------------------------------

前台页面有一个表单需要提交。

**Struts2 接收 request 参数**

```
		<form class="login-form" action="/login_do" method="post">
			<h3 class="form-title">登录系统</h3>
			<div class="alert alert-danger display-hide">
				<button class="close" data-close="alert"></button>
				<span> 请输入用户名和密码 </span>
			</div>
			<div class="form-group">
				<label class="control-label visible-ie8 visible-ie9">用户名</label>
				<div class="input-icon">
					<i class="fa fa-user"></i>
					<input class="form-control placeholder-no-fix" type="text" autocomplete="off" placeholder="用户名" name="account.id" />
				</div>
			</div>
			<div class="form-group">
				<label class="control-label visible-ie8 visible-ie9">密码</label>
				<div class="input-icon">
					<i class="fa fa-lock"></i>
					<input class="form-control placeholder-no-fix" type="password" autocomplete="off" placeholder="密码" name="account.password" />
				</div>
			</div>
			<div class="form-actions">
				<button type="submit" class="btn green pull-right">
					登录 <i class="m-icon-swapright m-icon-white"></i>
				</button>
			</div>
		</form>
```

```
package com.jpkc.pojo;

import java.io.Serializable;

public class Account implements Serializable
{
	private String id;
	private String password;
	private String name;

	public Account()
	{
		super();
		// TODO Auto-generated constructor stub
	}

	public String getId()
	{
		return id;
	}

	public void setId(String id)
	{
		this.id = id;
	}

	public String getPassword()
	{
		return password;
	}

	public void setPassword(String password)
	{
		this.password = password;
	}

	public String getName()
	{
		return name;
	}

	public void setName(String name)
	{
		this.name = name;
	}
}

```

```
package com.jpkc.action;

import java.util.HashMap;
import java.util.Map;

import com.jpkc.common.CM;
import com.jpkc.pojo.Account;

public class AccountAction extends BaseAction
{
	private Account account;

	public String login_do()
	{
		String method = getRequest().getMethod();
		if (method.toUpperCase().equals("GET"))
		{
			return "404";
		}
		if (account == null || CM.validIsEmpty(account.getId()) || CM.validIsEmpty(account.getPassword()))
		{
			return ERROR;
		}

		getSession().setAttribute("accountSession", account);
		return SUCCESS;
	}

	public Account getAccount()
	{
		return account;
	}

	public void setAccount(Account account)
	{
		this.account = account;
	}
}
```


**SpringMVC 接收 request 参数**

```
		<form class="login-form" action="admin/login_do" method="post">
			<h3 class="form-title">登录系统</h3>
			<div class="alert alert-danger display-hide">
				<button class="close" data-close="alert"></button>
				<span> 请输入用户名和密码 </span>
			</div>
			<div class="form-group">
				<label class="control-label visible-ie8 visible-ie9">用户名</label>
				<div class="input-icon">
					<i class="fa fa-user"></i>
					<input class="form-control placeholder-no-fix" type="text" autocomplete="off" placeholder="用户名" name="id" />
				</div>
			</div>
			<div class="form-group">
				<label class="control-label visible-ie8 visible-ie9">密码</label>
				<div class="input-icon">
					<i class="fa fa-lock"></i>
					<input class="form-control placeholder-no-fix" type="password" autocomplete="off" placeholder="密码" name="password" />
				</div>
			</div>
			<div class="form-actions">
				<button type="submit" class="btn green pull-right">
					登录 <i class="m-icon-swapright m-icon-white"></i>
				</button>
			</div>
		</form>
```


```
package com.jpkc.pojo;

import java.io.Serializable;

public class Account implements Serializable
{
	private String id;
	private String password;
	private String name;

	public Account()
	{
		super();
		// TODO Auto-generated constructor stub
	}

	public String getId()
	{
		return id;
	}

	public void setId(String id)
	{
		this.id = id;
	}

	public String getPassword()
	{
		return password;
	}

	public void setPassword(String password)
	{
		this.password = password;
	}

	public String getName()
	{
		return name;
	}

	public void setName(String name)
	{
		this.name = name;
	}
}

```

```
package com.jpkc.controller;

import java.util.HashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import com.jpkc.common.CM;
import com.jpkc.exception.CustomException;
import com.jpkc.mapper.CourseInfoMapper;
import com.jpkc.pojo.Account;
import com.jpkc.pojo.CourseInfo;
import com.jpkc.service.LoginService;

@RequestMapping("/admin")
@Controller
public class LoginController
{
	@Autowired
	LoginService loginService;

	@RequestMapping(value = "/login_do", method = { RequestMethod.POST })
	public void login_do(ModelAndView model, HttpServletRequest request, HttpServletResponse response, HttpSession session, Account account) throws Exception
	{
		response.setCharacterEncoding("utf-8");
		response.setContentType("application/json;charset=utf-8");
		Map<String, Object> json = new HashMap<String, Object>();
		String info;

		if (account == null || CM.validIsEmpty(account.getId()) || CM.validIsEmpty(account.getPassword()))
		{
			info = "用户名、密码都是必填项。";
			json.put("success", false);
			json.put("info", info);
			response.getWriter().write(new ObjectMapper().writeValueAsString(json));
			return;
		}

		session.setAttribute("accountSession", account);
		json.put("success", true);
		response.getWriter().write(new ObjectMapper().writeValueAsString(json));
		return;

	}
}
```

----------

Struts2单个方法可以处理一个request，接收参数Account需要定义一个成员变量，Struts2会自动将对应的参数调用成员变量的set方法设置进去。处理方法可以在方法内获取到。用完还存在request级别Map中。

SpringMVC的单个方法也对应于一个request，接收参数Account需要定义一个方法参数，SpringMVC会自动将对应的参数设置到方法参数中去。处理方法可以在方法内获取到。用完即销毁。

可以看出两种框架都可以实现参数的自动转换。Struts2定义一个成员变量，其他方法都是可以共享的，不用重新定义。SpringMVC每个方法都是独立的，方法参数是每一个方法独享的。

各有利弊。

成员变量共享可以避免重复定义，但是方法一多，用到的成员变量原来越多，整个Action类会惨不忍睹，因为你不知道其中一个方法具体会用到哪几个成员变量。而且用不到的成员变量也被存储到request级别Map中了。造成内存的浪费。

方法参数是方法独享的。则不能复用到其他方法，但是对于当前方法来说有哪些参数足够明确，而且不用和其他方法搅合，干脆利落。

从JVM角度来说，Struts2成员变量会被分配到堆中。SpringMVC方法参数则会存在于方法栈中，一般认为栈比堆更轻量一些，方法结束，用完参数即回收。堆需要垃圾回收触发时才能统一回收。

**Struts2 和 SpringMVC 限制访问方式GET和POST的不同**
------------------------------

在上例中，表单提交有密码，需要指定只接受POST提交方式。

**Struts2指定POST方式**

```
	public String login_do()
	{
		String method = getRequest().getMethod();
		if (method.toUpperCase().equals("GET"))
		{
			return "404";
		}
	}
```

**SpringMVC指定POST方式**

```
	@RequestMapping(value = "/login_do", method = { RequestMethod.POST })
	public void login_do(ModelAndView model, HttpServletRequest request, HttpServletResponse response, HttpSession session, Account account) throws Exception
	{
		response.setCharacterEncoding("utf-8");
		response.setContentType("application/json;charset=utf-8");
		Map<String, Object> json = new HashMap<String, Object>();
		String info;

		if (account == null || CM.validIsEmpty(account.getId()) || CM.validIsEmpty(account.getPassword()))
		{
			info = "用户名、密码都是必填项。";
			json.put("success", false);
			json.put("info", info);
			response.getWriter().write(new ObjectMapper().writeValueAsString(json));
			return;
		}

		session.setAttribute("accountSession", account);
		json.put("success", true);
		response.getWriter().write(new ObjectMapper().writeValueAsString(json));
		return;

	}
```


----------
Struts2限制只能通过POST方式访问，是通过调用request的getMethod方法来得到当前访问方式。然后手工的去判断。

SpringMVC也可以调用request的getMethod方法来判断，但是框架本身提供了方便的内置判断。使用注解即可。

Struts2通过拦截器设置好访问方式的代码后，也可以通过注解的方式指定拦截器得到同样的效果。本身不是太难的事情，两个框架都可以实现，Struts2需要手工实现，SpringMVC默认提供了。即使SpringMVC不提供，调用SpringMVC的拦截器也能和Struts2的拦截器的效果一样。在GET和POST访问限制方面，并没有谁优谁劣，都可以实现。只是SpringMVC愿意往前多走一小步。

**Struts2 和 SpringMVC 拦截器的不同**
------------------------------

后台页面需要登录，我们可以使用拦截器限制未登录的用户访问。

**Struts2实现拦截器的方式**

```
public class ManagerLoginInterceptor extends AbstractInterceptor
{
	@Override
	public String intercept(ActionInvocation invocation) throws Exception
	{
		String actionName = ServletActionContext.getActionMapping().getName();
		// 如果是登录、注册、退出的话就不要拦截了
		if (actionName.equals("exit") || actionName.equals("login") || actionName.equals("login_do") || actionName.equals("regist")
				|| actionName.equals("regist_do"))
		{
			return invocation.invoke();
		}
		
		// 如果不是管理员就不能进入
		Manager managerTemp = (Manager) ServletActionContext.getRequest().getSession().getAttribute("managerSession");
		if (managerTemp == null)
		{
			return "manager_login";
		}

		//验证成功，放行。
		return invocation.invoke();
	}
}
```

```
	<package name="admin_package" namespace="/admin" extends="ssh-default">

		<interceptors>
			<interceptor name="LoginManagerValidate" class="com.example.interceptor.ManagerLoginInterceptor">
			</interceptor>
			<!-- 自定义拦截器栈-拦截未登录的管理员- -->
			<interceptor-stack name="LoginManagerValidateStack">
				<interceptor-ref name="LoginManagerValidate"></interceptor-ref>
				<interceptor-ref name="defaultStack"></interceptor-ref>
			</interceptor-stack>
		</interceptors>

		<action name="m_*" class="com.example.action.ManagerAction" method="m_{1}">
			<interceptor-ref name="LoginManagerValidateStack"></interceptor-ref>
			<result name="success" type="json">
				<param name="root">json</param>
			</result>
		</action>
	</package>
```

Struts2还提供了很多默认的拦截器供用户调用。

```
<interceptors>  
           <interceptor name="alias"class="com.opensymphony.xwork2.interceptor.AliasInterceptor"/>  
           <interceptor name="autowiring"class="com.opensymphony.xwork2.spring.interceptor.ActionAutowiringInterceptor"/>  
           <interceptor name="chain"class="com.opensymphony.xwork2.interceptor.ChainingInterceptor"/>  
           <interceptor name="conversionError"class="org.apache.struts2.interceptor.StrutsConversionErrorInterceptor"/>  
           <interceptor name="clearSession"class="org.apache.struts2.interceptor.ClearSessionInterceptor"/>  
           <interceptor name="createSession"class="org.apache.struts2.interceptor.CreateSessionInterceptor"/>  
           <interceptor name="debugging"class="org.apache.struts2.interceptor.debugging.DebuggingInterceptor"/>  
           <interceptor name="externalRef"class="com.opensymphony.xwork2.interceptor.ExternalReferencesInterceptor"/>  
           <interceptor name="execAndWait"class="org.apache.struts2.interceptor.ExecuteAndWaitInterceptor"/>  
           <interceptor name="exception"class="com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor"/>  
           <interceptor name="fileUpload"class="org.apache.struts2.interceptor.FileUploadInterceptor"/>  
           <interceptor name="i18n"class="com.opensymphony.xwork2.interceptor.I18nInterceptor"/>  
           <interceptor name="logger"class="com.opensymphony.xwork2.interceptor.LoggingInterceptor"/>  
           <interceptor name="modelDriven"class="com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor"/>  
           <interceptor name="scopedModelDriven"class="com.opensymphony.xwork2.interceptor.ScopedModelDrivenInterceptor"/>  
           <interceptor name="params"class="com.opensymphony.xwork2.interceptor.ParametersInterceptor"/>  
           <interceptor name="actionMappingParams"class="org.apache.struts2.interceptor.ActionMappingParametersInteceptor"/>  
           <interceptor name="prepare"class="com.opensymphony.xwork2.interceptor.PrepareInterceptor"/>  
           <interceptor name="staticParams"class="com.opensymphony.xwork2.interceptor.StaticParametersInterceptor"/>  
           <interceptor name="scope"class="org.apache.struts2.interceptor.ScopeInterceptor"/>  
           <interceptor name="servletConfig"class="org.apache.struts2.interceptor.ServletConfigInterceptor"/>  
           <interceptor name="sessionAutowiring"class="org.apache.struts2.spring.interceptor.SessionContextAutowiringInterceptor"/>  
           <interceptor name="timer"class="com.opensymphony.xwork2.interceptor.TimerInterceptor"/>  
           <interceptor name="token"class="org.apache.struts2.interceptor.TokenInterceptor"/>  
           <interceptor name="tokenSession"class="org.apache.struts2.interceptor.TokenSessionStoreInterceptor"/>  
           <interceptor name="validation"class="org.apache.struts2.interceptor.validation.AnnotationValidationInterceptor"/>  
           <interceptor name="workflow"class="com.opensymphony.xwork2.interceptor.DefaultWorkflowInterceptor"/>  
           <interceptor name="store"class="org.apache.struts2.interceptor.MessageStoreInterceptor"/>  
           <interceptor name="checkbox"class="org.apache.struts2.interceptor.CheckboxInterceptor"/>  
           <interceptor name="profiling"class="org.apache.struts2.interceptor.ProfilingActivationInterceptor"/>  
           <interceptor name="roles"class="org.apache.struts2.interceptor.RolesInterceptor"/>  
           <interceptor name="jsonValidation"class="org.apache.struts2.interceptor.validation.JSONValidationInterceptor"/>  
           <interceptornameinterceptorname="annotationWorkflow"class="com.opensymphony.xwork2.interceptor.annotations.AnnotationWorkflowInterceptor"/>  
```

**SpringMVC实现拦截器的方式**

```
public class LoginInterceptor implements HandlerInterceptor
{

	// 进入 Handler方法之前执行
	// 用于身份认证、身份授权
	// 比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception
	{

		// 获取请求的url
		String url = request.getRequestURI();
		// 判断url是否是公开 地址（实际使用时将公开 地址配置配置文件中）
		// 这里公开地址是登陆提交的地址
		if (url.indexOf("login") >= 0 || url.indexOf("exit") >= 0)
		{
			// 如果进行登陆提交，放行
			return true;
		}

		// 判断session
		HttpSession session = request.getSession();
		// 从session中取出用户身份信息
		Account account = (Account) session.getAttribute("accountSession");

		if (account != null)
		{
			// 身份存在，放行
			return true;
		}

		// 执行这里表示用户身份需要认证，跳转登陆页面
		request.getRequestDispatcher("/manager/login.jsp").forward(request, response);

		// return false表示拦截，不向下执行
		// return true表示放行
		return false;
	}

	// 进入Handler方法之后，返回modelAndView之前执行
	// 应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图
	@Override
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception
	{

		System.out.println("HandlerInterceptor1...postHandle");

	}

	// 执行Handler完成执行此方法
	// 应用场景：统一异常处理，统一日志处理
	@Override
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception
	{

		System.out.println("HandlerInterceptor1...afterCompletion");
	}
}

```

```
	<!--拦截器 -->
	<mvc:interceptors>
		<!--多个拦截器,顺序执行 -->
		<!-- 登录认证拦截器 -->
		<mvc:interceptor>
			<mvc:mapping path="/admin/**" />
			<bean class="com.jpkc.interceptor.LoginInterceptor"></bean>
		</mvc:interceptor>
	</mvc:interceptors>
```


----------
拦截器实现机制上，Struts2有自己的interceptor机制，SpringMVC用的是独立的AOP方式。都可以实现在前后进行拦截。


**Struts2 和 SpringMVC 支持 JSON 的不同**
---------------------------------

有时我们界面的一些操作，是通过 Ajax 调用后台的服务，获取服务器返回的 json 数据，进行后续的操作。

**Struts2 实现JSON数据返回的方式**

```
		<action name="login_do" class="com.jpkc.action.AccountAction" method="login_do">
			<result name="success" type="json">
				<!-- 这里指定将被Struts2序列化的属性，该属性在action中必须有对应的getter方法 -->
				<param name="root">json</param>
			</result>
		</action>
```

```

public class AccountAction extends BaseAction
{
	// 常用变量
	private Map<String, Object> json;// 返回到前台的map对象
	private Account account;

	public AccountAction()
	{
		json = new HashMap<String, Object>();
	}

	public String login_do()
	{
		if (account == null || CM.validIsEmpty(account.getId()) || CM.validIsEmpty(account.getPassword()))
		{
			info = "用户名、密码都是必填项。";
			json.put("success", false);
			json.put("info", info);
			return SUCCESS;
		}

		getSession().setAttribute("accountSession", account);
		json.put("success", true);
		return SUCCESS;

	}
}
```

```
$.post("login_do", $(".login-form").serialize(), function(json)
{
	if (json.success == true)
	{
		window.location.href="shop/index.jsp";
	}
	else
	{
		alert("操作失败：" + json.info);
	}
}, "json");
```

**SpringMVC 实现JSON数据返回的方式**

```
	<!--注解适配器 -->
	<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
		<property name="messageConverters">
		<list>
		<bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"></bean>
		</list>
		</property>
	</bean>

```

```
$.post("login_do", $(".login-form").serialize(), function(json)
{
	if (json.success == true)
	{
		window.location.href="shop/index.jsp";
	}
	else
	{
		alert("操作失败：" + json.info);
	}
}, "json");
```

SpringMVC在控制器中返回json有两种方式。

一种是使用response返回json。

```
	@RequestMapping(value = "/login_do", method = { RequestMethod.POST })
	public void login_do(ModelAndView model, HttpServletRequest request, HttpServletResponse response, HttpSession session, Account account) throws Exception
	{
		response.setCharacterEncoding("utf-8");
		response.setContentType("application/json;charset=utf-8");
		Map<String, Object> json = new HashMap<String, Object>();
		String info;

		if (account == null || CM.validIsEmpty(account.getId()) || CM.validIsEmpty(account.getPassword()))
		{
			info = "用户名、密码都是必填项。";
			json.put("success", false);
			json.put("info", info);
			response.getWriter().write(new ObjectMapper().writeValueAsString(json));
			return;
		}

		session.setAttribute("accountSession", account);
		json.put("success", true);
		response.getWriter().write(new ObjectMapper().writeValueAsString(json));
		return;

	}
```
另一种是使用@ResponseBody注解方式。

```
	@RequestMapping(value = "/login_do", method = { RequestMethod.POST })
	public @ResponseBody Map<String, Object> login_do(ModelAndView model, HttpServletRequest request, HttpServletResponse response, HttpSession session, Account account) throws Exception
	{
		Map<String, Object> json = new HashMap<String, Object>();
		String info;

		if (account == null || CM.validIsEmpty(account.getId()) || CM.validIsEmpty(account.getPassword()))
		{
			info = "用户名、密码都是必填项。";
			json.put("success", false);
			json.put("info", info);
			return json;
		}

		session.setAttribute("accountSession", account);
		json.put("success", true);
		return json;

	}
```


----------
可以看出，Struts2 和 SpringMVC 都可以实现 Ajax 请求返回 JSON。实现方式上，Struts2在配置文件配置返回类型为JSON。SpringMVC在方法上加一个@ResponseBody注解即可返回对应类型转成的JSON字符串。都是对返回数据转成JSON，但是不得不说SpringMVC的写法方便太多了。


**Hibernate 和 MyBatis 在 ORM 侧重点的不同**
------------------------------------

Hibernate对数据库结构提供了较为完整的封装，Hibernate的O/R Mapping实现了POJO 和数据库表之间的映射，以及SQL 的自动生成和执行。程序员往往只需定义好了POJO 到数据库表的映射关系，即可通过Hibernate 提供的方法完成持久层操作。程序员甚至不需要对SQL 的熟练掌握， **Hibernate/OJB 会根据指定的存储逻辑，自动生成对应的SQL** 并调用JDBC 接口加以执行。

**MyBatis 的着力点，则在于POJO 与SQL之间的映射关系**。然后通过映射配置文件，将SQL所需的参数，以及返回的结果字段映射到指定POJO。 相对Hibernate“O/R”而言，MyBatis 是一种“Sql Mapping”的ORM实现。

**SQL语句支持**：Hibernate可以完全不用手写SQL语句，MyBatis手动维护SQL语句。Hibernate修改优化SQL语句困难，MyBatis由于SQL语句自己控制，优化非常方便。

**开发速度**：Hibernate的真正掌握要比Mybatis来得难些。Mybatis框架相对简单很容易上手，但也相对简陋些。

**开发社区**：Hibernate 与Mybatis都是流行的持久层开发框架，但Hibernate开发社区相对多热闹些，支持的工具也多，更新也快。而Mybatis相对平静，工具较少。

**开发工作量**：Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。

针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。

**Hibernate 和 MyBatis 在调优方面的不同**
------------------------------------

 - 制定合理的缓存策略； 
 - 尽量使用延迟加载特性； 
 - 采用合理的Session管理机制；   

**SQL优化方面**

Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。

Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。

**扩展性方面**

Hibernate与具体数据库的关联只需在XML文件中配置即可，所有的HQL语句与具体使用的数据库无关，移植性很好。MyBatis项目中所有的SQL语句都是依赖所用的数据库的，所以不同数据库类型的支持不好。

**Hibernate 和 MyBatis 在对象管理与抓取策略的不同**
------------------------------------

**对象管理**

Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。

换句话说，使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。

而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。当调用sqlSession.commit()方法时才会进行真正的提交。

**抓取策略**

Hibernate对实体关联对象的抓取有着良好的机制。对于每一个关联关系都可以详细地设置是否延迟加载，并且提供关联抓取、查询抓取、子查询抓取、批量抓取四种模式。 它是详细配置和处理的。

而Mybatis的延迟加载是全局配置的，在resultMap中使用association中的select指定延迟加载去执行的statement的id。

```
	<!-- 延迟加载的resultMap -->
	<resultMap type="cn.itcast.mybatis.po.Orders" id="OrdersUserLazyLoadingResultMap">
			<!--对订单信息进行映射配置  -->
			<id column="id" property="id"/>
			<result column="user_id" property="userId"/>
			<result column="number" property="number"/>
			<result column="createtime" property="createtime"/>
			<result column="note" property="note"/>
			
			<association property="user"  javaType="cn.itcast.mybatis.po.User"
			 select="cn.itcast.mybatis.mapper.UserMapper.findUserById" column="user_id">
			<!-- 实现对用户信息进行延迟加载 -->
			</association>
	</resultMap>
```

**Hibernate 和 MyBatis 在缓存机制的不同**
------------------------------------

**Hibernate缓存**
Hibernate一级缓存是Session缓存，利用好一级缓存就需要对Session的生命周期进行管理好。建议在一个Action操作中使用一个Session。一级缓存需要对Session进行严格管理。

Hibernate二级缓存是SessionFactory级的缓存。 SessionFactory的缓存分为内置缓存和外置缓存。内置缓存中存放的是SessionFactory对象的一些集合属性包含的数据(映射元素据及预定SQL语句等),对于应用程序来说,它是只读的。外置缓存中存放的是数据库数据的副本,其作用和一级缓存类似.二级缓存除了以内存作为存储介质外,还可以选用硬盘等外部存储设备。二级缓存称为进程级缓存或SessionFactory级缓存，它可以被所有session共享，它的生命周期伴随着SessionFactory的生命周期存在和消亡。

**MyBatis缓存**
MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。MyBatis 3 中的缓存实现的很多改进都已经实现了,使得它更加强大而且易于配置。

一级缓存是SqlSession级别的缓存，二级缓存是mapper(命名空间)级别的缓存，默认情况下是没有开启二级缓存的。

要开启二级缓存,你需要在你的 SQL 映射文件中添加一行:  `<cache/>`

字面上看就是这样。这个简单语句的效果如下:

映射语句文件中的所有 select 语句将会被缓存。
映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。
缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。
根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。
缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。
缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。
所有的这些属性都可以通过缓存元素的属性来修改。

比如: `<cache  eviction="FIFO"  flushInterval="60000"  size="512"  readOnly="true"/>`

这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。可用的收回策略有, 默认的是 LRU:

LRU – 最近最少使用的:移除最长时间不被使用的对象。
FIFO – 先进先出:按对象进入缓存的顺序来移除它们。
SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。
WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。
flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。

size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是1024。

readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。

**相同点**
Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。

**不同点**
Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。

MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。

**两者比较**
因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。

而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。

**Hibernate 和 MyBatis 对比总结**
-------------------------

**两者相同点**

Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。

Hibernate和MyBatis都支持JDBC和JTA事务处理。

**Mybatis优势**

MyBatis可以进行更为细致的SQL优化，可以减少查询字段。

MyBatis容易掌握，而Hibernate门槛较高。

**Hibernate优势**

Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。

Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。

Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。

Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳，更新操作不能指定刷新指定记录，会清空整个表，但是也可以使用第三方缓存。


----------
Hibernate 封装性好，屏蔽了数据库差异，自动生成SQL语句，应对数据库变化能力较弱，SQL语句优化困难。

MyBatis仅实现了SQL语句和对象的映射，需要针对具体的数据库写SQL语句，应对数据库变化能力较强，SQL语句优化较为方便。

**SSH 和 SSM 对比总结**
------------------

SSH 和 SSM 的技术框架的不同只需要比较Struts2和SpringMVC的不同，以及Hibernate和MyBatis的不同。

对于不同的功能，两大技术阵营均有对应的解决方案。SSH将配置文件开发用到极致。SSM将注解开发用到极致。

企业进行技术选型，以低成本高回报作为技术选型的原则，根据项目组的技术力量来进行选择。

小弟水平有限，只能总结到这里。更进一步的底层代码级别的对比，才是本质的区别。用法上的区别只是表象而已，但是对于广大开发者来说，谁的开发者用户体验好，显然更能赢得开发者的青睐。

我在GitHub上上传了同一个项目分别用SSH和SSM开发的例子。仅供参考。[https://github.com/ganecheng/SSH_SSM](https://github.com/ganecheng/SSH_SSM)

这里有一份Java工具和技术的调查，可以参考一下，[http://f.dataguru.cn/article-9978-1.html](http://f.dataguru.cn/article-9978-1.html)

**参考文献**
--------

[http://blog.csdn.net/firejuly/article/details/8190229](http://blog.csdn.net/firejuly/article/details/8190229)

[http://blog.csdn.net/chenyi0834/article/details/7334963](http://blog.csdn.net/chenyi0834/article/details/7334963)

[http://blog.csdn.net/gane_cheng/article/details/52787040](http://blog.csdn.net/gane_cheng/article/details/52787040)

[http://blog.csdn.net/gane_cheng/article/details/52759099](http://blog.csdn.net/gane_cheng/article/details/52759099)

[http://blog.csdn.net/gane_cheng/article/details/52751206](http://blog.csdn.net/gane_cheng/article/details/52751206)

[http://blog.csdn.net/chenleixing/article/details/44570681](http://blog.csdn.net/chenleixing/article/details/44570681)